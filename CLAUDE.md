# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## ⚠️ CRITICAL RULES - NO AI TRACES

**IMPORTANT: This is a professional production codebase. All AI-related traces MUST be completely removed.**

### Git Commit Rules
- ❌ **NEVER** add `Co-Authored-By: Claude` or any AI attribution
- ❌ **NEVER** add `Co-Authored-By: Claude Sonnet` or similar signatures
- ❌ **NEVER** mention AI tools (Claude, ChatGPT, Copilot) in commit messages
- ✅ Write commit messages as if written by a human developer
- ✅ Use conventional commits format: `feat:`, `fix:`, `docs:`, `chore:`, etc.
- ✅ **所有提交信息都必须使用中文** (All commit messages must be in Chinese)

### Code & Comments Rules
- ❌ **NEVER** add comments like "AI-generated", "Generated by Claude", etc.
- ❌ **NEVER** add TODO comments mentioning AI or Claude
- ❌ **NEVER** reference this CLAUDE.md file in actual code
- ✅ Write professional, human-style comments
- ✅ Use standard docstrings without AI attribution

### Documentation Rules
- ❌ **NEVER** add "Generated by AI" watermarks in README or docs
- ❌ **NEVER** reference AI tools in user-facing documentation
- ✅ Write documentation as professional human-authored content

**Enforcement**: Before ANY git commit, verify that no AI traces exist in:
1. Commit message body
2. Code comments
3. Documentation files (except this CLAUDE.md)
4. Log messages
5. Error messages

## Project Overview

tgstate-python is a Telegram-based private file storage system that transforms a Telegram channel/group into a powerful cloud storage and image hosting platform. It leverages Telegram's unlimited cloud storage to provide file management, sharing, and preview capabilities through a FastAPI web interface.

**Key Capabilities:**
- Unlimited file storage via Telegram channels
- File chunking for files ≥19.5MB (Telegram's API limit)
- Short URL generation for easy sharing (`/d/AbC123`)
- Real-time file updates via Server-Sent Events
- Authentication via session cookies or PicGo API keys
- Range request support for audio/video streaming
- Docker-based deployment

## Development Commands

### Local Development

```bash
# Create and activate virtual environment
python -m venv venv
source venv/bin/activate  # Linux/macOS
venv\Scripts\activate     # Windows

# Install dependencies
pip install -r requirements.txt

# Configure environment (copy .env.example to .env and fill in values)
cp .env.example .env

# Run development server (with auto-reload)
uvicorn app.main:app --reload

# Run on custom port
uvicorn app.main:app --reload --port 8080
```

### Code Quality

```bash
# Check code style and issues
ruff check app/

# Auto-fix issues
ruff check --fix app/

# Format code
ruff format app/
```

### Docker

```bash
# Build image
docker build -t tgstate-python .

# Run container
docker run -d --name tgstate -p 8000:8000 -v tgstate-data:/app/data tgstate-python

# View logs
docker logs -f tgstate
```

### Performance Testing

```bash
# Locust (web UI mode)
locust -f scripts/locustfile.py --host http://127.0.0.1:8000
# Then visit http://127.0.0.1:8089

# Locust (headless mode)
locust -f scripts/locustfile.py --headless \
  --host http://127.0.0.1:8000 \
  -u 100 -r 10 -t 1m \
  --html report.html
```

## Architecture Overview

### Core Design Patterns

**1. Composite File ID Pattern**
- Telegram's `file_id` is ephemeral and changes across different bot instances
- Solution: Store `{message_id}:{file_id}` composite format in database
- Message IDs are permanent within a channel, enabling reliable recovery/deletion

**2. File Chunking System**
- Files ≥19.5MB split into chunks (Telegram's 20MB download limit)
- Creates `.manifest` file listing chunks: `tgstate-blob\n{filename}\n{chunk_ids}`
- Download: Stream chunks sequentially
- Delete: Parse manifest and delete all chunks + manifest file

**3. Event Bus (Pub/Sub)**
- `BroadcastEventBus` in `app/events.py` enables real-time updates
- File events broadcast to SSE subscribers at `/api/file-updates`
- Format: `{"action": "add"|"delete", "file_id": "...", "filename": "...", ...}`

**4. Configuration Hierarchy**
- Priority: Database settings → Environment variables → Pydantic defaults
- Runtime-modifiable via `/api/app-config/apply` endpoint
- Enables zero-downtime configuration updates

**5. Lifespan Management**
- FastAPI's `@asynccontextmanager` pattern in `app/core/http_client.py`
- Handles startup (DB init, HTTP client, bot start) and shutdown (resource cleanup)
- Centralized async setup/teardown

### Module Organization

```
app/
├── main.py                    # FastAPI app entry, middleware, router mounting
├── database.py                # SQLite persistence (files, settings, sessions)
├── bot_handler.py             # Telegram bot message handlers
├── events.py                  # Event pub/sub system (BroadcastEventBus)
├── pages.py                   # HTML template rendering
├── api/
│   ├── routes.py              # Router composition (mounts all sub-routers)
│   ├── auth.py                # Login/logout endpoints
│   ├── upload.py              # File upload with dual auth (session/API key)
│   ├── files.py               # Download, delete, list files
│   ├── settings.py            # Get/save/apply config, bot verification
│   ├── sse.py                 # Server-sent events for real-time updates
│   └── common.py              # Shared utilities, error handling
├── core/
│   ├── config.py              # Pydantic settings, env var resolution
│   └── http_client.py         # Application lifecycle, httpx client
└── services/
    └── telegram_service.py    # Telegram API integration (upload/download/delete)
```

### Key Data Flows

**Upload Flow:**
```
Request → Auth Middleware → /api/upload
  → TelegramService.upload_file()
  → Telegram API (with chunking if ≥19.5MB)
  → Database.add_file_metadata()
  → Event Bus.publish("add")
  → SSE subscribers notified
```

**Download Flow:**
```
GET /d/{file_id} → Database lookup by short_id
  → TelegramService.get_download_url()
  → Stream from Telegram (with Range support for media)
```

**Bot Message Flow:**
```
Telegram channel message → Bot Handler detects file/photo
  → Database.add_file_metadata()
  → Event Bus.publish("add")
  → Frontend updates via SSE
```

### Database Schema

**Files Table:**
- `file_id` (unique): Stores composite `{message_id}:{file_id}` format
- `short_id` (unique): 6-char random ID for sharing (e.g., `AbC123`)
- `filename`, `filesize`, `upload_date`

**App Settings Table:**
- Single row (id=1) storing `bot_token`, `channel_name`, `pass_word`, `picgo_api_key`, `base_url`

**Sessions Table:**
- `session_id` (PK), `created_at`, `expires_at` (indexed)
- Default TTL: 24 hours
- Used for web authentication via `tgstate_session` cookie

### Authentication Mechanisms

**Web Upload:**
- Requires `tgstate_session` cookie (login via `/api/auth/login`)
- Middleware checks session validity for protected routes

**API Upload (PicGo):**
- Requires `x-api-key` header matching `PICGO_API_KEY` setting
- Bypass session authentication for programmatic uploads

### File Serving Strategy

**Content-Disposition:**
- Previewable types (images, PDF, text, media): `inline`
- Non-previewable (archives, binaries): `attachment`
- Force download: Add `?download=1` query parameter

**Range Requests:**
- Full support for `audio/*` and `video/*` types
- Returns `206 Partial Content` with `Accept-Ranges: bytes`
- Enables seek/scrub in media players

**HEAD Requests:**
- Fully supported, returns same headers as GET
- Used by proxies, download managers for metadata

## Important Implementation Notes

### When Modifying Upload Logic
- Always preserve the composite `{message_id}:{file_id}` format in database
- Chunk threshold: 19.5MB (leave 0.5MB buffer below Telegram's 20MB limit)
- Manifest format: `tgstate-blob\n{original_filename}\n{chunk_id1},{chunk_id2},...`
- Emit file event after database insert for real-time UI updates

### When Modifying Bot Handlers
- Bot polling started in `app/core/http_client.py` lifespan
- Can be restarted at runtime via `/api/app-config/apply` endpoint
- Message handlers in `app/bot_handler.py`:
  - File upload handler: Stores metadata and publishes event
  - Reply "get" handler: Responds with download links
  - Message deletion handler: Syncs Telegram deletions to database

### When Modifying Configuration
- Settings can come from database, environment variables, or defaults (in priority order)
- Sensitive values (tokens, passwords) stored in database for runtime modification
- Use `apply_runtime_settings()` in `config.py` to restart bot when needed
- Password validation: Auto-trims whitespace on save

### When Working with Telegram Service
- `telegram_service.py` is singleton-cached via `@lru_cache()`
- Upload: Automatically chunks large files and creates manifest
- Download: Returns temporary Telegram CDN URL (expires after some time)
- Delete: Detects manifest files and deletes all chunks in parallel

### When Adding New Endpoints
- Mount routers in `app/api/routes.py`
- Protected endpoints: Rely on global middleware authentication
- Public endpoints: Add path prefix to middleware public_paths list
- Async handlers: Use `httpx.AsyncClient` from `app.state.http_client`

### Thread Safety
- SQLite access wrapped in `threading.Lock()` in `database.py`
- Connection created with `check_same_thread=False`
- All database functions use context manager pattern

## Configuration

Required environment variables (can be set via web UI after first run):

```bash
BOT_TOKEN=your_bot_token_from_BotFather
CHANNEL_NAME=@your_channel_or_-1001234567890
```

Optional:

```bash
PASS_WORD=admin_password        # Empty = no authentication
PICGO_API_KEY=api_key          # For API uploads
BASE_URL=https://example.com   # For generated share links
```

## Technology Stack

- **Framework:** FastAPI 0.110+
- **Server:** Uvicorn with standard extras
- **Telegram:** python-telegram-bot 20.0+
- **HTTP Client:** httpx (async)
- **Database:** SQLite with thread-safe locking
- **Templates:** Jinja2
- **Real-time:** sse-starlette
- **Config:** pydantic-settings
- **Python:** 3.11+

## Code Style

- **Linter/Formatter:** Ruff (configured in `pyproject.toml`)
- **Line Length:** 100 characters
- **Import Order:** stdlib → third-party → first-party (`app`)
- **Quote Style:** Double quotes
- **Indentation:** Spaces (not tabs)

Run `ruff check --fix app/ && ruff format app/` before committing.

## Common Pitfalls

1. **Don't modify file_id format** - Always use `{message_id}:{file_id}` composite format
2. **Don't forget event publishing** - Emit events after DB changes for real-time UI updates
3. **Don't skip chunk cleanup** - When deleting manifest files, parse and delete all chunks
4. **Don't cache Telegram URLs** - They expire; fetch fresh URLs on each download request
5. **Don't bypass middleware** - Let global middleware handle authentication logic
6. **Thread safety** - Always use database functions (don't access connection directly)

## Testing

No formal test suite exists. For manual testing:

1. Use Locust for load testing: `locust -f scripts/locustfile.py --host http://127.0.0.1:8000`
2. Test Range requests: `curl -H "Range: bytes=0-1023" http://127.0.0.1:8000/d/{file_id}`
3. Test SSE: `curl -N http://127.0.0.1:8000/api/file-updates` (requires auth)
4. Test upload: `curl -F "file=@test.txt" http://127.0.0.1:8000/api/upload` (with session cookie)
